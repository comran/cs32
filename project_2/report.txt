1)
My Sequence implementation makes use of a singly linked list, where the first/last elements are preceded/followed by null pointers. To find an element at a given index, I wrote code to begin at a start node and traverse the array by using each node's pointer to the next/preious nodes. Whenever a node was inserted or deleted, the next/previous pointers of neighboring elements would be updated to maintain the new order of the Sequence. An empty sequence would simply consist of a start pointer to the null pointer, and any value that is inserted later on would make start pointer point to that node.

start_node >      node #1                 node #2                    node #3
             previous: nullptr          previous: node #1        previous: node #2
               next: node #2            next: node #3             next: nullptr
                  "test1"                  "test2"                  "test3"

2) Pseudocode
bool Sequence::insert(int pos, const ItemType &value) {
  if pos is out of bounds:
    return false

  increment size
  create a new unlinked node containing value
  if inserting at position 0:
    if start_node_ is not empty:
      link the new node before the current start_node_
    replace start_node_ with the new node
    return true

  loop until a pointer to the node before position is found
  cache a pointer to the node that will follow the new node
  if a node exists after the new node:
    link the node after new node to new node
  link the new node to the nodes before and after it

  return true
}

int Sequence::insert(const ItemType &value) {
  if Sequence is empty:
    delete start_node_ if it still points to something
    generate a new unlinked node containing value
    point start_node_ towards this new node
    increment size

  loop until values of all nodes before index i are less than value
  insert a new node at i

  return true
}

bool Sequence::erase(int pos) {
  if pos is out of bounds:
    return false

  initialize current_node to point at the start of the sequence
  if erasing the first node:
    if there is an element after the first node:
      unlink the second element from the first element in the sequence
      cache a pointer to the second element
      delete the first element
      replace the start node with the second element
  else
    loop until current node points at the node to be erased
    if a node before current node exists:
      link this node to the node after current node
    if a node after current node exists:
      link this node to the node before current node
    delete current node

  decrement size
  return true
}

int Sequence::remove(const ItemType &value) {
  initialize the count of items removed to zero

  point current node to the start of sequence
  for every element in sequence:
    if the value of the current element equals the parameter value:
      cache the node after current node
      delete the matching element
      decrement size
      increment the count of items deleted
    else:
      point current node to the node after it

  return number of items removed
}


void Sequence::swap(Sequence &other) {
  cache the original size of this object
  set the size of this object to the size of the other object
  set the size of the other object to the cached size

  cache the start node of this object
  set the start node of this object to the start node of the other object
  set the start node of the other object to the cached start node
}

int subsequence(const Sequence &searched_sequence,
                const Sequence &query_sequence) {
  if query_sequence is empty or is bigger than what searched_sequence can hold:
    return a failure code

  for every element in searched_sequence:
    get the value of the current element of searched_sequence
    get the value of the first element of query_sequence
    if these two values do not match:
      go to the next element in searched_sequence

    initialize a variable tracking to see if the current sequence may be a match
    for every element after the first in query_sequence:
      if the element offsetted by the index of the current element of query_sequence is not equal to the element of query sequence:
        report an unmatched sequence

    if sequence was found:
      return index of start of sequence

  return an error code for a failed search
}

void interleave(const Sequence &seq1, const Sequence &seq2, Sequence &result) {
  erase all elements in result

  if there are no elements in seq1:
    return seq2
  else if there are no elements in seq2 as well:
    return the empty seq1

  initialize variables tracking the current index of seq1 and seq2
  while there are still elements that have not been interweaved in result:
    add an element from seq1 to result, if such an element exists
    add an element from seq2 to result, if such an element exists
}

3) Test cases
#include "Sequence.h"
#include <string>
#include "Sequence.h"

#include <iostream>
#include <cassert>
using namespace std;

void test() {
  Sequence *s = new Sequence();
  {
    // Make sure Sequence is empty when given no copy constructor and nothing to
    // insert.
    assert(s->size() == 0 && s->empty());
  }

  {
    // Test that insert works when adding multiple items.
    s->insert("TEST1");
    assert(s->size() == 1 && !s->empty());
    s->insert("TEST3");
    s->insert("TEST2");
    s->insert("TEST0");
    s->insert("TEST0");
    s->insert("TEST0");
    s->insert("TEST0");
    s->insert("TEST0");
    assert(s->size() == 8);
  }

  {
    // Test that get() works and that the one-parameter insert instance inserted
    // according to alphabetical order.
    int i;
    ItemType item, last_item;
    for (i = 0; s->get(i, item); i++) {
      if (i > 0) assert(item > last_item || item == last_item);
      last_item = item;
    }
  }

  {
    // Test that find works.
    ItemType item_at_index;
    assert(s->get(s->find("TEST2"), item_at_index) && item_at_index == "TEST2");
  }

  {
    // Test that remove works and that it caught all instances.
    assert(s->remove("TEST0") == 5 && s->find("TEST0") == -1);

    ItemType item;
    for (int i = 0; s->get(i, item); i++) {
      assert(item != "TEST0");
    }
  }

  {
    // Test that insert only works within the bounds of the Sequence.
    assert(!s->insert(s->size() + 1, "TEST4") && s->find("TEST4") == -1);
    assert(!s->insert(-1, "TEST4") && s->find("TEST4") == -1);
    assert(s->insert(s->size(), "TEST4") && s->find("TEST4") == s->size() - 1);
  }

  {
    // Test that erase only works within the bounds of Sequence.
    assert(!s->erase(s->size()) && s->find("TEST4") == s->size() - 1);
    assert(!s->erase(-1) && s->find("TEST4") == s->size() - 1);
    assert(s->erase(s->size() - 1) && s->find("TEST4") == -1);
  }

  {
    // Test that set only works within the bounds of Sequence and doesn't add
    // a new item.
    assert(!s->set(s->size(), "TEST4") && s->find("TEST4") == -1);
    assert(!s->set(-1, "TEST4") && s->find("TEST4") == -1);
    assert(s->set(s->size() - 1, "TEST4") && s->find("TEST4") == s->size() - 1);
  }

  {
    // Test that swap works.
    Sequence *g = new Sequence();
    g->insert(0, "TEST7");
    g->insert(1, "TEST8");

    ItemType item;
    assert(s->size() == 3 && s->get(0, item) && item == "TEST1" &&
           s->get(1, item) && item == "TEST2" && s->get(2, item) &&
           item == "TEST4");
    assert(g->size() == 2 && g->get(0, item) && item == "TEST7" &&
           g->get(1, item) && item == "TEST8");

    s->swap(*g);

    assert(g->size() == 3 && g->get(0, item) && item == "TEST1" &&
           g->get(1, item) && item == "TEST2" && g->get(2, item) &&
           item == "TEST4");
    assert(s->size() == 2 && s->get(0, item) && item == "TEST7" &&
           s->get(1, item) && item == "TEST8");

    // Test that swap still works on empty sequences.
    while (s->size() > 0) s->erase(0);
    assert(s->size() == 0);
    assert(g->size() == 3);
    s->swap(*g);
    assert(s->size() == 3);
    assert(g->size() == 0);

    delete g;
  }

  assert(s->set(s->size() - 1, "TEST3"));  // Restore some order to s first...
  assert(s->insert("TEST4") == s->size() - 1);
  assert(s->insert("TEST5") == s->size() - 1);

  {
    // Test if subsequence fails to find a sequence that does not exist in the
    // searched sequence.
    Sequence *g = new Sequence();
    g->insert(0, "TEST2");
    g->insert(1, "TEST4");
    g->insert(2, "TEST3");

    assert(subsequence(*s, *g) == -1);

    *g = *s;  // Test copy opeeration.

    // Test that a subsequence of s can be found.

    // Erase part of g so it turns into a subsequence of s.
    for (int i = 0; i < 3; i++) g->erase(0);
    assert(subsequence(*s, *g) == 3);

    delete g;
  }

  {
    // Test that interleave produces a properly interweaved Sequence.
    Sequence *g = new Sequence(), *h = new Sequence();
    g->insert(0, "TEST5");
    g->insert(1, "TEST6");
    g->insert(2, "TEST7");

    interleave(*s, *g, *h);

    ItemType item;
    assert(h->size() == s->size() + g->size() && h->get(0, item) &&
           item == "TEST1" && h->get(1, item) && item == "TEST5" &&
           h->get(2, item) && item == "TEST2" && h->get(3, item) &&
           item == "TEST6" && h->get(4, item) && item == "TEST3" &&
           h->get(5, item) && item == "TEST7" && h->get(6, item) &&
           item == "TEST4" && h->get(7, item) &&
           item == "TEST5");

    delete g;
    delete h;
  }

  {
    // Test that interleave properly deals with aliasing.
    // The following should not result in an infinite loop, and should instead
    // simply clear s.
    int s_size = s->size();
    interleave(*s, *s, *s);
    assert(s->size() == s_size * 2);
  }

  while(s->size() > 0) s->erase(0);

  s->insert("TEST1");
  s->insert("TEST2");
  s->insert("TEST3");
  s->insert("TEST4");
  s->insert("TEST5");

  {
    // Test that the copy constructor works.
    Sequence *g = new Sequence(*s);
    ItemType item, item2;
    for (int i = 0; s->get(i, item) && g->get(i, item2); i++) {
      assert(item == item2);
    }

    delete g;
  }

  delete s;
}

int main() {
  test();
  cout << "Passed all tests" << endl;
}
