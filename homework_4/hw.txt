2) Calling the one-argument form of Sequence<Complex>::insert causes a compilation error because that version of insert requires a greater than (>) operator to compare two Complex classes to keep the sequence ordered. Since we did not define an override for that operator, it is undefined and therefore results in a compilation error when the compiler attempts to find an implementation of that operator while compiling the one-argument form of insert.

4a) O(N^3) since there are three nested loops that will run a maximum of N times. Although there are if statements that run once during two of the loops, the worse case for all loops run up to N operations. Therefore, for the 3 nested loops, this results in N * N * N, or N^3 -- which is also the highest order component that details the time complexity for this implementation of a mutual friend algorithm.

4b) O(N^3) because there are three nested loops that, in the worse case, all go from 0 to N. Although the second nested loop will average out to a range from 0 to N / 2, the coefficient will be disregarded for the final Big-O formula. Therefore, Big-O for this algorithm is (outermost loop) N * N / 2 * N (innermost loop) = N^3 / 2. The coefficient is not considered for the final Big-O answer, so we get N^3 -- the same answer we arrived at for part A.

5a) O(N^2) because, combined with the calls to the single-parameter version of insert, the loops used may call insert N times, which itself is an O(N) operation. Since seq1 and seq2 both have a size of N, the first loop will run from 0 to N. Within this loop, get is called twice and sequence is called twice. Both of these are O(N) operations -- making this first part of the algorithm take (4N)^2 operations. For the second for loop, n1 is equal to n2, therefore this part of the algorithm will not run with the given input. In any case, the final Big-O for this algorithm is O(N^2) (since the coefficient is disregarded).

5b) O(N) because this implementation uses an insert implementation that is O(1), as opposed to the other algorithms that used an insert that took O(N). This optimization comes from the fact that this algorithm's choice of an insert function can simply slide new values into a linked list at the specified node (which found beforehand by the parent for loop). The second for loop (which fills in any remaining values from the sequence that were not interwoven) also has a big-O of O(N) because, worst case scenario, this loop will have to insert N items. Since this also uses the same insert algorithm that takes O(1) operations, it has the same big-O. Therefore, the overall big-O of this algorithm is O(N) since, again, coefficients do not matter for big-O.
