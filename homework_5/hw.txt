1)
a)
50
    20
        10
            xx
            15
        40
            30
                25
                35
            xx
    60
        xx
        70
            65
            80
                75
                xx

b)
inorder:
10
15
25
30
35
40
50
60
65
70
75
80

preorder:
50
20
10
15
40
30
25
35
60
70
65
80
75

postorder:
15
10
25
35
30
40
20
65
75
80
70
60
50

c)
remove node and its children from the tree, and re-order all children of the deleted node (preorder).

50
    10
        xx
        15
            xx
            40
                25
                    xx
                    35
                xx
    60
        xx
        70
            65
            80
                75
                xx


2)
a)
struct Node {
  Node(int value_param, Node *parent_param) : value(value_param),
                        parent(parent_param), left(nullptr), right(nullptr) {}
  int value;
  Node *parent;
  Node *left;
  Node *right;
};

b)
void insert(Node *head, int value) {
  run insertRecursive with head and value, and use nullptr as the parent
}

void insertRecursive(Node *branch, Node *parent, int value) {
  if branch is nullptr:
    create new Node holding value and parent points to parent
  else if branch's value is less than parameter value:
    run insertRecursive with branch's left node, value, and the current branch as parent
  else:
    run insertRecursive with branch's right node, value, and the current branch as parent
}

3)
a)
8
  3
    0
    2
  6
    4
    xx

b)
8 3 6 0 2 4

c)
6 3 4 0 2

4)
a) O(C + S)
b) O(log(C) + S)
c) O(log(C) + log(S))
d) O(log(S))
e) O(1)
f) O(log(C) + S)
g) O(S)
h) O(Clog(S))
